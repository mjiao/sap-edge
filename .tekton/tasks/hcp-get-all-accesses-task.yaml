# SPDX-FileCopyrightText: 2025 SAP edge team
# SPDX-FileContributor: Manjun Jiao (@mjiao)
#
# SPDX-License-Identifier: Apache-2.0

---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: hcp-get-all-accesses
spec:
  description: >-
    Retrieves and displays all PostgreSQL and Redis credentials from the hosted
    cluster after deployment. Also displays the content of generated certificate files.
  params:
    - name: hostedClusterName
      type: string
      description: "Name of the hosted cluster"
    - name: hostedClusterNamespace
      type: string
      description: "Namespace for HostedCluster resources"
      default: "clusters"
    - name: hubKubeconfigSecretName
      type: string
      description: "Name of the Secret containing kubeconfig for hub cluster (optional)"
      default: ""
  workspaces:
    - name: source
  results:
    - name: postgres-host
      description: "PostgreSQL host"
    - name: postgres-port
      description: "PostgreSQL port"
    - name: redis-host
      description: "Redis host"
    - name: redis-port
      description: "Redis port"
  steps:
    - name: get-all-accesses
      image: registry.access.redhat.com/ubi9/ubi
      workingDir: $(workspaces.source.path)
      timeout: "336h"
      env:
        - name: HOSTED_CLUSTER_NAME
          value: "$(params.hostedClusterName)"
        - name: HOSTED_CLUSTER_NAMESPACE
          value: "$(params.hostedClusterNamespace)"
        - name: HUB_KUBECONFIG_SECRET
          value: "$(params.hubKubeconfigSecretName)"
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        echo "=============================================="
        echo "ðŸ“‹ Retrieving All Access Credentials"
        echo "=============================================="
        echo ""

        # Install required packages
        echo "ðŸ“¦ Installing required packages..."
        dnf install -y jq wget &>/dev/null

        # Install OpenShift CLI
        echo "ðŸ“¦ Installing OpenShift CLI..."
        curl -sL https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/openshift-client-linux.tar.gz -o /tmp/oc.tar.gz
        tar xzf /tmp/oc.tar.gz -C /tmp
        mv /tmp/oc /usr/local/bin/
        cp /usr/local/bin/oc /usr/local/bin/kubectl
        rm -f /tmp/oc.tar.gz
        oc version --client

        # Configure hub cluster kubeconfig if provided
        if [[ -n "${HUB_KUBECONFIG_SECRET}" ]]; then
          echo "ðŸ” Extracting hub cluster kubeconfig from secret: ${HUB_KUBECONFIG_SECRET}..."
          HUB_KUBECONFIG="/tmp/hub-kubeconfig"
          # Try different common key names for kubeconfig in secrets
          if kubectl get secret "${HUB_KUBECONFIG_SECRET}" -o jsonpath='{.data.kubeconfig}' 2>/dev/null | base64 -d > "${HUB_KUBECONFIG}" 2>/dev/null && [[ -s "${HUB_KUBECONFIG}" ]]; then
            echo "âœ… Kubeconfig extracted (key: kubeconfig)"
          elif kubectl get secret "${HUB_KUBECONFIG_SECRET}" -o jsonpath='{.data.config}' 2>/dev/null | base64 -d > "${HUB_KUBECONFIG}" 2>/dev/null && [[ -s "${HUB_KUBECONFIG}" ]]; then
            echo "âœ… Kubeconfig extracted (key: config)"
          elif kubectl get secret "${HUB_KUBECONFIG_SECRET}" -o jsonpath='{.data.value}' 2>/dev/null | base64 -d > "${HUB_KUBECONFIG}" 2>/dev/null && [[ -s "${HUB_KUBECONFIG}" ]]; then
            echo "âœ… Kubeconfig extracted (key: value)"
          else
            echo "âŒ Failed to extract kubeconfig from secret '${HUB_KUBECONFIG_SECRET}'"
            echo "   Secret should have kubeconfig data under key 'kubeconfig', 'config', or 'value'"
            exit 1
          fi
          chmod 600 "${HUB_KUBECONFIG}"
          export KUBECONFIG="${HUB_KUBECONFIG}"
          echo "âœ… Using hub kubeconfig for cluster operations"
          oc whoami
        else
          echo "â„¹ï¸  No hub kubeconfig secret provided, using in-cluster service account"
        fi

        # Extract kubeconfig for hosted cluster
        echo "ðŸ” Extracting kubeconfig for hosted cluster..."
        KUBECONFIG_SECRET="${HOSTED_CLUSTER_NAME}-admin-kubeconfig"

        if ! oc get secret "${KUBECONFIG_SECRET}" -n "${HOSTED_CLUSTER_NAMESPACE}" > /dev/null 2>&1; then
          echo "âŒ Kubeconfig secret '${KUBECONFIG_SECRET}' not found in namespace '${HOSTED_CLUSTER_NAMESPACE}'"
          exit 1
        fi

        HOSTED_KUBECONFIG="/tmp/hosted-kubeconfig"
        oc get secret "${KUBECONFIG_SECRET}" -n "${HOSTED_CLUSTER_NAMESPACE}" \
          -o jsonpath='{.data.kubeconfig}' | base64 -d > "${HOSTED_KUBECONFIG}"
        chmod 600 "${HOSTED_KUBECONFIG}"

        # Set KUBECONFIG to hosted cluster
        export KUBECONFIG="${HOSTED_KUBECONFIG}"

        echo "ðŸ” Verifying access to hosted cluster..."
        oc get nodes
        echo "âœ… Successfully connected to hosted cluster"
        echo ""

        # Run the get_all_accesses.sh script if it exists
        GET_ACCESS_SCRIPT="./edge-integration-cell/get_all_accesses.sh"

        if [[ -f "${GET_ACCESS_SCRIPT}" ]]; then
          echo "ðŸ”§ Running get_all_accesses.sh script..."
          chmod +x "${GET_ACCESS_SCRIPT}"

          # Run the script and capture output
          "${GET_ACCESS_SCRIPT}" || echo "âš ï¸ Script completed with warnings"

          echo ""
          echo "=============================================="
          echo "ðŸ“„ Certificate File Contents"
          echo "=============================================="
          echo ""

          # Display PostgreSQL TLS certificate if generated
          if [[ -f "external_postgres_db_tls_root_cert.crt" ]]; then
            echo "ðŸ“œ PostgreSQL TLS Root Certificate (external_postgres_db_tls_root_cert.crt):"
            echo "----------------------------------------------"
            cat external_postgres_db_tls_root_cert.crt
            echo ""
            echo "----------------------------------------------"
            echo ""
          fi

          # Display Redis TLS certificate if generated
          if [[ -f "external_redis_tls_certificate.pem" ]]; then
            echo "ðŸ“œ Redis TLS Certificate (external_redis_tls_certificate.pem):"
            echo "----------------------------------------------"
            cat external_redis_tls_certificate.pem
            echo ""
            echo "----------------------------------------------"
            echo ""
          fi
        else
          echo "âš ï¸ get_all_accesses.sh not found, retrieving credentials manually..."
          echo ""

          # ================== PostgreSQL ==================
          echo "=====================================Postgres========================================="

          PG_NAMESPACE="sap-eic-external-postgres"
          PG_SECRET="eic-pguser-eic"

          if oc get secret "${PG_SECRET}" -n "${PG_NAMESPACE}" &>/dev/null; then
            PG_HOST=$(oc get secret "${PG_SECRET}" -n "${PG_NAMESPACE}" -o jsonpath="{.data.host}" | base64 --decode)
            PG_PORT=$(oc get secret "${PG_SECRET}" -n "${PG_NAMESPACE}" -o jsonpath="{.data.port}" | base64 --decode)
            PG_DBNAME=$(oc get secret "${PG_SECRET}" -n "${PG_NAMESPACE}" -o jsonpath="{.data.dbname}" | base64 --decode)
            PG_USER=$(oc get secret "${PG_SECRET}" -n "${PG_NAMESPACE}" -o jsonpath="{.data.user}" | base64 --decode)
            PG_PASSWORD=$(oc get secret "${PG_SECRET}" -n "${PG_NAMESPACE}" -o jsonpath="{.data.password}" | base64 --decode)

            echo "External DB Hostname: ${PG_HOST}"
            echo "External DB Port: ${PG_PORT}"
            echo "External DB Name: ${PG_DBNAME}"
            echo "External DB Username: ${PG_USER}"
            echo "External DB Password: ${PG_PASSWORD}"

            # Save results
            echo -n "${PG_HOST}" > $(results.postgres-host.path)
            echo -n "${PG_PORT}" > $(results.postgres-port.path)

            # Get TLS certificate
            PGO_SECRET="pgo-root-cacert"
            if oc get secret "${PGO_SECRET}" -n "${PG_NAMESPACE}" &>/dev/null; then
              ROOT_CRT=$(oc get secret "${PGO_SECRET}" -n "${PG_NAMESPACE}" -o json | jq -r '.data["root.crt"]' | base64 -d)
              if [[ -n "${ROOT_CRT}" ]]; then
                echo "${ROOT_CRT}" > external_postgres_db_tls_root_cert.crt
                echo "External DB TLS Root Certificate saved to external_postgres_db_tls_root_cert.crt"
                echo ""
                echo "ðŸ“œ PostgreSQL TLS Root Certificate content:"
                echo "----------------------------------------------"
                cat external_postgres_db_tls_root_cert.crt
                echo "----------------------------------------------"
              fi
            fi
          else
            echo "âš ï¸ PostgreSQL secret not found in ${PG_NAMESPACE}"
            echo -n "N/A" > $(results.postgres-host.path)
            echo -n "N/A" > $(results.postgres-port.path)
          fi

          echo ""

          # ================== Redis ==================
          echo "======================================Redis==========================================="

          REDIS_NAMESPACE="sap-eic-external-redis"
          REDIS_DB="redb"

          if oc get RedisEnterpriseDatabase "${REDIS_DB}" -n "${REDIS_NAMESPACE}" &>/dev/null; then
            REDIS_SECRET=$(oc get RedisEnterpriseDatabase "${REDIS_DB}" -n "${REDIS_NAMESPACE}" -o json | jq -r '.spec.databaseSecretName')

            if [[ -n "${REDIS_SECRET}" ]] && [[ "${REDIS_SECRET}" != "null" ]]; then
              SECRET_DATA=$(oc get secret "${REDIS_SECRET}" -n "${REDIS_NAMESPACE}" -o json)
              REDIS_PASSWORD=$(echo "${SECRET_DATA}" | jq -r '.data["password"]' | base64 --decode)
              REDIS_PORT=$(echo "${SECRET_DATA}" | jq -r '.data["port"]' | base64 --decode)
              REDIS_SERVICE=$(echo "${SECRET_DATA}" | jq -r '.data["service_name"]' | base64 --decode)

              REDIS_SERVICE_FQDN="${REDIS_SERVICE}.${REDIS_NAMESPACE}.svc"
              REDIS_SERVER_NAME="rec.${REDIS_NAMESPACE}.svc.cluster.local"

              echo "External Redis Addresses: ${REDIS_SERVICE_FQDN}:${REDIS_PORT}"
              echo "External Redis Mode: standalone"
              echo "External Redis Username: [leave me blank]"
              echo "External Redis Password: ${REDIS_PASSWORD}"
              echo "External Redis Sentinel Username: [leave me blank]"
              echo "External Redis Sentinel Password: [leave me blank]"
              echo "External Redis Server Name: ${REDIS_SERVER_NAME}"

              # Save results
              echo -n "${REDIS_SERVICE_FQDN}" > $(results.redis-host.path)
              echo -n "${REDIS_PORT}" > $(results.redis-port.path)

              # Get TLS certificate from Redis pod
              echo ""
              echo "ðŸ” Extracting Redis TLS certificate..."
              if oc get pod rec-0 -n "${REDIS_NAMESPACE}" &>/dev/null; then
                oc exec -n "${REDIS_NAMESPACE}" rec-0 -c redis-enterprise-node -- \
                  cat /etc/opt/redislabs/proxy_cert.pem > external_redis_tls_certificate.pem 2>/dev/null || true

                if [[ -f "external_redis_tls_certificate.pem" ]] && [[ -s "external_redis_tls_certificate.pem" ]]; then
                  echo "External Redis TLS Certificate saved to external_redis_tls_certificate.pem"
                  echo ""
                  echo "ðŸ“œ Redis TLS Certificate content:"
                  echo "----------------------------------------------"
                  cat external_redis_tls_certificate.pem
                  echo "----------------------------------------------"
                fi
              else
                echo "âš ï¸ Redis pod rec-0 not found, skipping TLS certificate extraction"
              fi
            else
              echo "âš ï¸ Redis database secret not found"
              echo -n "N/A" > $(results.redis-host.path)
              echo -n "N/A" > $(results.redis-port.path)
            fi
          else
            echo "âš ï¸ RedisEnterpriseDatabase not found in ${REDIS_NAMESPACE}"
            echo -n "N/A" > $(results.redis-host.path)
            echo -n "N/A" > $(results.redis-port.path)
          fi
        fi

        echo ""
        echo "=============================================="
        echo "âœ… All credentials retrieved successfully!"
        echo "=============================================="
