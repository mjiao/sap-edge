# SPDX-FileCopyrightText: 2025 SAP edge team
# SPDX-FileContributor: Manjun Jiao (@mjiao)
#
# SPDX-License-Identifier: Apache-2.0

---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: ossm3-generate-sa-based-kubeconfig
spec:
  description: >-
    Generate a restricted-access kubeconfig file for SAP Edge Lifecycle
    Management. Creates a dedicated service account with a long-lived token
    and produces a kubeconfig file for registering the cluster in ELM.
  params:
    - name: hostedClusterName
      type: string
      description: "Name of the hosted cluster"
    - name: hostedClusterNamespace
      type: string
      description: "Namespace for HostedCluster resources"
      default: "clusters"
    - name: hubKubeconfigSecretName
      type: string
      description: "Name of the Secret containing kubeconfig for hub cluster (optional, uses in-cluster config if empty)"
      default: ""
  workspaces:
    - name: source
  results:
    - name: kubeconfig-info
      description: "Summary of the generated kubeconfig"
  steps:
    - name: generate-sa-based-kubeconfig
      image: registry.access.redhat.com/ubi9/ubi
      timeout: "336h"
      workingDir: $(workspaces.source.path)
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        CLUSTER_NAME="$(params.hostedClusterName)"
        CLUSTER_NS="$(params.hostedClusterNamespace)"
        HUB_KUBECONFIG_SECRET="$(params.hubKubeconfigSecretName)"

        echo "=========================================="
        echo "OSSM3 Generate SA-Based Kubeconfig Task"
        echo "=========================================="
        echo "Hosted Cluster: ${CLUSTER_NAME}"
        echo "Cluster Namespace: ${CLUSTER_NS}"
        echo "=========================================="

        # Install required tools
        echo "üì¶ Installing required packages..."
        dnf install -y jq > /dev/null 2>&1

        echo "üì¶ Installing OpenShift CLI..."
        curl -sL https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/openshift-client-linux.tar.gz -o /tmp/oc.tar.gz
        tar xzf /tmp/oc.tar.gz -C /tmp
        mv /tmp/oc /usr/local/bin/
        cp /usr/local/bin/oc /usr/local/bin/kubectl
        rm -f /tmp/oc.tar.gz
        oc version --client

        # Configure hub cluster kubeconfig if provided
        if [[ -n "${HUB_KUBECONFIG_SECRET}" ]]; then
          echo "üîê Extracting hub cluster kubeconfig from secret: ${HUB_KUBECONFIG_SECRET}..."
          HUB_KUBECONFIG="/tmp/hub-kubeconfig"
          if kubectl get secret "${HUB_KUBECONFIG_SECRET}" -o jsonpath='{.data.kubeconfig}' 2>/dev/null | base64 -d > "${HUB_KUBECONFIG}" 2>/dev/null && [[ -s "${HUB_KUBECONFIG}" ]]; then
            echo "‚úÖ Kubeconfig extracted (key: kubeconfig)"
          elif kubectl get secret "${HUB_KUBECONFIG_SECRET}" -o jsonpath='{.data.config}' 2>/dev/null | base64 -d > "${HUB_KUBECONFIG}" 2>/dev/null && [[ -s "${HUB_KUBECONFIG}" ]]; then
            echo "‚úÖ Kubeconfig extracted (key: config)"
          elif kubectl get secret "${HUB_KUBECONFIG_SECRET}" -o jsonpath='{.data.value}' 2>/dev/null | base64 -d > "${HUB_KUBECONFIG}" 2>/dev/null && [[ -s "${HUB_KUBECONFIG}" ]]; then
            echo "‚úÖ Kubeconfig extracted (key: value)"
          else
            echo "‚ùå Failed to extract kubeconfig from secret '${HUB_KUBECONFIG_SECRET}'"
            echo "   Secret should have kubeconfig data under key 'kubeconfig', 'config', or 'value'"
            exit 1
          fi
          chmod 600 "${HUB_KUBECONFIG}"
          export KUBECONFIG="${HUB_KUBECONFIG}"
          echo "‚úÖ Using hub kubeconfig for cluster operations"
          oc whoami
        else
          echo "‚ÑπÔ∏è  No hub kubeconfig secret provided, using in-cluster service account"
        fi

        # Extract kubeconfig for hosted cluster
        echo "üîê Extracting kubeconfig for hosted cluster..."
        KUBECONFIG_SECRET="${CLUSTER_NAME}-admin-kubeconfig"

        if ! oc get secret "${KUBECONFIG_SECRET}" -n "${CLUSTER_NS}" > /dev/null 2>&1; then
          echo "‚ùå Kubeconfig secret '${KUBECONFIG_SECRET}' not found in namespace '${CLUSTER_NS}'"
          exit 1
        fi

        HOSTED_KUBECONFIG="/tmp/hosted-kubeconfig"
        oc get secret "${KUBECONFIG_SECRET}" -n "${CLUSTER_NS}" \
          -o jsonpath='{.data.kubeconfig}' | base64 -d > "${HOSTED_KUBECONFIG}"
        chmod 600 "${HOSTED_KUBECONFIG}"

        export KUBECONFIG="${HOSTED_KUBECONFIG}"

        echo "üîç Verifying access to hosted cluster..."
        oc get nodes
        echo "‚úÖ Successfully connected to hosted cluster"

        # --- 1. Create the 'edgelm' service account ---
        echo ""
        echo "üîß Creating 'edgelm' service account in 'edgelm' namespace..."
        if oc get sa edgelm -n edgelm &>/dev/null; then
          echo "   Service account 'edgelm' already exists"
        else
          oc create sa edgelm -n edgelm
          echo "‚úÖ Service account 'edgelm' created"
        fi

        # --- 2. Create token secret for long-lived service account token ---
        echo ""
        echo "üîß Creating long-lived token secret..."
        cat <<EOF | oc apply -n edgelm -f -
        apiVersion: v1
        kind: Secret
        metadata:
          name: edgelm-kubeconfig-token
          annotations:
            kubernetes.io/service-account.name: edgelm
        type: kubernetes.io/service-account-token
        EOF
        echo "‚úÖ Token secret 'edgelm-kubeconfig-token' created"

        # --- Wait for token to be populated ---
        echo ""
        echo "‚è≥ Waiting for token to be populated..."
        RETRY=0
        MAX_RETRIES=30
        while [[ ${RETRY} -lt ${MAX_RETRIES} ]]; do
          TOKEN=$(oc get secret edgelm-kubeconfig-token -n edgelm -o jsonpath='{.data.token}' 2>/dev/null || true)
          if [[ -n "${TOKEN}" ]]; then
            echo "‚úÖ Token is populated"
            break
          fi
          RETRY=$((RETRY + 1))
          echo "   Waiting for token... (${RETRY}/${MAX_RETRIES})"
          sleep 2
        done

        if [[ -z "${TOKEN:-}" ]]; then
          echo "‚ùå Token was not populated within the timeout"
          exit 1
        fi

        # --- 3. Extract token and generate kubeconfig ---
        echo ""
        echo "üîß Generating edgelm-kubeconfig file..."
        TOKEN_DECODED=$(echo "${TOKEN}" | base64 -d)

        # Get the cluster server URL from the current kubeconfig
        CLUSTER_SERVER=$(oc config view --minify -o jsonpath='{.clusters[0].cluster.server}')
        echo "   Cluster server: ${CLUSTER_SERVER}"

        # Get the cluster name from the current kubeconfig
        KC_CLUSTER_NAME=$(oc config view --minify -o jsonpath='{.clusters[0].name}')
        echo "   Cluster name: ${KC_CLUSTER_NAME}"

        # Get CA data if available
        CA_DATA=$(oc config view --raw --minify -o jsonpath='{.clusters[0].cluster.certificate-authority-data}' 2>/dev/null || true)

        # Build the kubeconfig file
        EDGELM_KUBECONFIG="/tmp/edgelm-kubeconfig"

        if [[ -n "${CA_DATA}" ]]; then
          cat > "${EDGELM_KUBECONFIG}" <<KUBEEOF
        apiVersion: v1
        kind: Config
        clusters:
          - cluster:
              certificate-authority-data: ${CA_DATA}
              server: ${CLUSTER_SERVER}
            name: ${KC_CLUSTER_NAME}
        contexts:
          - context:
              cluster: ${KC_CLUSTER_NAME}
              user: edgelm
            name: edgelm@${KC_CLUSTER_NAME}
        current-context: edgelm@${KC_CLUSTER_NAME}
        users:
          - name: edgelm
            user:
              token: ${TOKEN_DECODED}
        KUBEEOF
        else
          cat > "${EDGELM_KUBECONFIG}" <<KUBEEOF
        apiVersion: v1
        kind: Config
        clusters:
          - cluster:
              insecure-skip-tls-verify: true
              server: ${CLUSTER_SERVER}
            name: ${KC_CLUSTER_NAME}
        contexts:
          - context:
              cluster: ${KC_CLUSTER_NAME}
              user: edgelm
            name: edgelm@${KC_CLUSTER_NAME}
        current-context: edgelm@${KC_CLUSTER_NAME}
        users:
          - name: edgelm
            user:
              token: ${TOKEN_DECODED}
        KUBEEOF
        fi

        echo "‚úÖ Kubeconfig file generated at ${EDGELM_KUBECONFIG}"

        # --- Verify the generated kubeconfig ---
        echo ""
        echo "üîç Verifying generated kubeconfig..."
        if oc --kubeconfig="${EDGELM_KUBECONFIG}" auth can-i list pods -n edgelm; then
          echo "‚úÖ Kubeconfig verification passed: can list pods in edgelm namespace"
        else
          echo "‚ö†Ô∏è Kubeconfig verification: cannot list pods in edgelm namespace"
          echo "   This may be expected if RBAC roles have not been fully applied yet"
        fi

        # Test namespace access
        echo ""
        echo "üîç Testing namespace access with generated kubeconfig..."
        oc --kubeconfig="${EDGELM_KUBECONFIG}" get namespaces 2>/dev/null | grep -E "(edgelm|edge-icell|istio)" || echo "   Limited namespace visibility (expected for restricted access)"

        # --- Store kubeconfig as a Secret on the pipeline cluster ---
        echo ""
        echo "üîê Storing generated kubeconfig as a Secret on the pipeline cluster..."

        # Switch back to in-cluster credentials for storing the secret
        unset KUBECONFIG

        GENERATED_SECRET_NAME="edgelm-kubeconfig-generated-${CLUSTER_NAME}"
        KUBECONFIG_B64=$(base64 -w0 < "${EDGELM_KUBECONFIG}")
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Secret
        metadata:
          name: ${GENERATED_SECRET_NAME}
          labels:
            app.kubernetes.io/part-of: ossm3-restricted-access
            app.kubernetes.io/component: kubeconfig
        type: Opaque
        data:
          kubeconfig: ${KUBECONFIG_B64}
        EOF
        echo "‚úÖ Generated kubeconfig stored as Secret '${GENERATED_SECRET_NAME}'"

        # --- Output summary ---
        SUMMARY="Kubeconfig generated for cluster ${CLUSTER_SERVER}, SA edgelm@edgelm. Secret: ${GENERATED_SECRET_NAME}"
        echo -n "${SUMMARY}" > "$(results.kubeconfig-info.path)"

        echo ""
        echo "=========================================="
        echo "‚úÖ Kubeconfig generation completed"
        echo ""
        echo "   Cluster Server: ${CLUSTER_SERVER}"
        echo "   Service Account: edgelm (namespace: edgelm)"
        echo "   Token Secret: edgelm-kubeconfig-token"
        echo "   Generated Kubeconfig Secret: ${GENERATED_SECRET_NAME}"
        echo ""
        echo "   üìã Next Step: Register this cluster in the ELM UI"
        echo "   1. In the ELM UI, start 'Add an Edge Node'"
        echo "   2. Check 'Restricted Access to Kubernetes cluster'"
        echo "   3. Provide the kubeconfig from Secret '${GENERATED_SECRET_NAME}'"
        echo "=========================================="
