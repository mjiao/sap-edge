# SPDX-FileCopyrightText: 2025 SAP edge team
# SPDX-FileContributor: Manjun Jiao (@mjiao)
#
# SPDX-License-Identifier: Apache-2.0

---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: aro-validate-and-get-access
spec:
  params:
    - name: aroClusterName
      type: string
      description: "ARO cluster name"
    - name: azureSecretName
      type: string
      description: "Name of the Kubernetes Secret containing Azure service principal credentials and ARO resource group"
      default: "azure-sp-secret"
    - name: postgresAdminPasswordSecretName
      type: string
      description: "Name of the Kubernetes Secret containing PostgreSQL admin password"
      default: "azure-postgres-admin-password"
  results:
    - name: cluster-summary
      description: "Brief cluster and services summary (under 4KB)"
  workspaces:
    - name: source
  steps:
    - name: validate-and-get-access
      image: registry.access.redhat.com/ubi9/ubi
      timeout: "30m"       # Validation should be quick
      workingDir: $(workspaces.source.path)
      env:
        - name: ARO_CLUSTER_NAME
          value: "$(params.aroClusterName)"
      envFrom:
        - secretRef:
            name: $(params.azureSecretName)
        - secretRef:
            name: $(params.postgresAdminPasswordSecretName)
      script: |
        #!/usr/bin/env bash
        set -euo pipefail
        
        echo "ðŸ”§ Validating ARO cluster: ${ARO_CLUSTER_NAME}"
        echo "ðŸ“¦ Installing dependencies..."
        # Install Azure CLI using the official Microsoft repository
        rpm --import https://packages.microsoft.com/keys/microsoft.asc
        dnf install -y https://packages.microsoft.com/config/rhel/9.0/packages-microsoft-prod.rpm
        dnf clean all
        # Install required tools including Ansible
        dnf install -y azure-cli tar jq make libicu python3-pip
        
        # Install Ansible for cluster configuration
        echo "ðŸ“¦ Installing Ansible..."
        pip3 install ansible kubernetes

        # Install OpenShift CLI
        echo "ðŸ“¦ Installing OpenShift CLI..."
        curl -L https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz | tar -xz -C /usr/local/bin oc
        
        # Environment variables are now directly available from secrets (no conversion needed)
        
        echo "ðŸ” Logging into Azure..."
        make azure-login
        
        echo "ðŸ“‹ Setting subscription..."
        make azure-set-subscription
        
        echo "ðŸ” Validating ARO cluster..."
        
        # Wait for cluster to be ready
        echo "â³ Waiting for ARO cluster to be ready..."
        while true; do
          CLUSTER_STATUS=$(make --no-print-directory aro-cluster-status | tail -1)
          echo "Cluster status: '$CLUSTER_STATUS'"
          echo "Status length: ${#CLUSTER_STATUS}"
          
          if [[ "$CLUSTER_STATUS" == "Succeeded" ]]; then
            echo "âœ… ARO cluster is ready!"
            break
          elif [[ "$CLUSTER_STATUS" == "Failed" ]]; then
            echo "âŒ ARO cluster deployment failed!"
            exit 1
          else
            echo "â³ Cluster still provisioning... waiting 60 seconds"
            sleep 60
          fi
        done
        
        # Get cluster URL and credentials
        CLUSTER_URL=$(make --no-print-directory aro-cluster-url | tail -1)
        echo "ðŸ” Debug: Getting credentials..."
        CREDENTIALS_RAW=$(make --no-print-directory aro-credentials)
        echo "ðŸ” Debug: Raw credentials output:"
        echo "$CREDENTIALS_RAW"
        echo "ðŸ” Debug: End raw credentials"
        CREDENTIALS_JSON=$(echo "$CREDENTIALS_RAW" | grep -v "Variable is not defined" | grep -v "Not all required variables are defined" | grep -v "az aro list-credentials")
        echo "ðŸ” Debug: Filtered JSON:"
        echo "$CREDENTIALS_JSON"
        echo "ðŸ” Debug: End filtered JSON"
        USERNAME=$(echo "$CREDENTIALS_JSON" | jq -r '.kubeadminUsername')
        PASSWORD=$(echo "$CREDENTIALS_JSON" | jq -r '.kubeadminPassword')
        
        echo "ðŸŒ Cluster URL: $CLUSTER_URL"
        echo "ðŸ‘¤ Username: $USERNAME"
        echo "ðŸ”‘ Password: $PASSWORD"
        
        # Test cluster connectivity
        echo "ðŸ”— Testing cluster connectivity..."
        oc login "$CLUSTER_URL" -u "$USERNAME" -p "$PASSWORD" --insecure-skip-tls-verify=true
        
        echo "âœ… Cluster validation completed successfully!"
        echo ""
        
        # Generate kubeconfig
        echo "ðŸ“„ Generating kubeconfig..."
        # Get kubeconfig with insecure TLS settings
        make aro-get-kubeconfig
        
        echo "âœ… Kubeconfig generated and configured with insecure TLS!"
        echo "ðŸ“ Kubeconfig saved to: $(pwd)/kubeconfig"

        echo "==== BEGIN KUBECONFIG ===="
        cat kubeconfig
        echo "==== END KUBECONFIG ===="
        
        # Create a downloadable file in workspace
        cp kubeconfig kubeconfig-$(params.aroClusterName).yaml
        echo "âœ… Kubeconfig saved as: kubeconfig-$(params.aroClusterName).yaml"
        
        # Enable scheduling on master nodes
        echo ""
        echo "ðŸ”§ Enabling scheduling on master nodes..."
        export ARO_CLUSTER_NAME
        export ARO_RESOURCE_GROUP
        make aro-enable-master-scheduling
        
        echo ""
        echo "ðŸ” Getting Azure services information..."
        
        # Set expected service names based on cluster name
        EXPECTED_POSTGRES_NAME="postgres-${ARO_CLUSTER_NAME}"
        EXPECTED_REDIS_NAME="redis-${ARO_CLUSTER_NAME}"
        
        # Get PostgreSQL server information directly
        POSTGRES_SERVER_NAME=""
        POSTGRES_SERVER_FQDN=""
        POSTGRES_ADMIN_USERNAME="eicadmin"
        POSTGRES_DATABASE_NAME="eic"
        POSTGRES_CONNECTION_STRING=""
        POSTGRES_TLS_CERT_FILE=""
        
        POSTGRES_EXISTS=$(make --no-print-directory postgres-exists | tail -1)
        POSTGRES_PUBLIC_ACCESS=""
        POSTGRES_NETWORK_TYPE="Public Access"
        if [[ -n "$POSTGRES_EXISTS" ]]; then
          POSTGRES_SERVER_NAME="$EXPECTED_POSTGRES_NAME"
          POSTGRES_SERVER_FQDN="${EXPECTED_POSTGRES_NAME}.postgres.database.azure.com"
          
          # Check if public access is disabled (private endpoint/VNet integrated)
          POSTGRES_PUBLIC_ACCESS=$(az postgres flexible-server show \
            --resource-group "${ARO_RESOURCE_GROUP}" \
            --name "$POSTGRES_SERVER_NAME" \
            --query "network.publicNetworkAccess" -o tsv 2>/dev/null || echo "Enabled")
          
          if [[ "$POSTGRES_PUBLIC_ACCESS" == "Disabled" ]]; then
            POSTGRES_NETWORK_TYPE="Private Access (VNet Integrated)"
          fi
          
          # Build connection string with URL-encoded password for @ symbol
          if [[ -n "${POSTGRES_ADMIN_PASSWORD:-}" ]]; then
            # URL-encode the password to handle special characters like @
            POSTGRES_PASSWORD_ENCODED=$(printf %s "$POSTGRES_ADMIN_PASSWORD" | jq -sRr @uri)
            POSTGRES_CONNECTION_STRING="postgresql://${POSTGRES_ADMIN_USERNAME}:${POSTGRES_PASSWORD_ENCODED}@${POSTGRES_SERVER_FQDN}:5432/${POSTGRES_DATABASE_NAME}?sslmode=require"
          fi
          
          # Download PostgreSQL TLS root certificate (DigiCert Global Root G2)
          echo "ðŸ“¥ Downloading PostgreSQL TLS root certificate..."
          POSTGRES_TLS_CERT_FILE="external_postgres_db_tls_root_cert.crt"
          curl -sL https://cacerts.digicert.com/DigiCertGlobalRootG2.crt.pem -o "$POSTGRES_TLS_CERT_FILE"
          if [[ -f "$POSTGRES_TLS_CERT_FILE" ]]; then
            echo "âœ… PostgreSQL TLS certificate saved to $POSTGRES_TLS_CERT_FILE"
          else
            echo "âš ï¸  Failed to download PostgreSQL TLS certificate"
            POSTGRES_TLS_CERT_FILE=""
          fi
          
          echo "âœ… Found PostgreSQL server: $POSTGRES_SERVER_NAME ($POSTGRES_NETWORK_TYPE)"
        else
          echo "âš ï¸ PostgreSQL server not found: $EXPECTED_POSTGRES_NAME"
        fi
        
        # Get Redis cache information directly
        REDIS_CACHE_NAME=""
        REDIS_HOST_NAME=""
        REDIS_PORT=""
        REDIS_SSL_PORT=""
        REDIS_ACCESS_KEY=""
        REDIS_CONNECTION_STRING=""
        REDIS_PUBLIC_ACCESS=""
        REDIS_NETWORK_TYPE="Public Access"
        
        # Get Redis connection information using make target
        REDIS_INFO=$(make --no-print-directory redis-get-info 2>&1)
        echo "$REDIS_INFO"
        
        # Parse the output to extract values
        REDIS_CACHE_NAME=$(echo "$REDIS_INFO" | grep "^Redis Cache Name:" | cut -d: -f2- | xargs)
        REDIS_HOST_NAME=$(echo "$REDIS_INFO" | grep "^Redis Host:" | cut -d: -f2- | xargs)
        REDIS_PORT=$(echo "$REDIS_INFO" | grep "^Redis Port:" | cut -d: -f2- | xargs)
        REDIS_SSL_PORT=$(echo "$REDIS_INFO" | grep "^Redis SSL Port:" | cut -d: -f2- | xargs)
        REDIS_ACCESS_KEY=$(echo "$REDIS_INFO" | grep "^Redis Access Key:" | cut -d: -f2- | xargs)
        
        # Check if we actually found Redis by checking if cache name was extracted
        if [[ -n "$REDIS_CACHE_NAME" ]]; then
          # Check if public access is disabled (private endpoint)
          REDIS_PUBLIC_ACCESS=$(az redis show \
            --resource-group "${ARO_RESOURCE_GROUP}" \
            --name "$REDIS_CACHE_NAME" \
            --query "publicNetworkAccess" -o tsv 2>/dev/null || echo "Enabled")
          
          if [[ "$REDIS_PUBLIC_ACCESS" == "Disabled" ]]; then
            REDIS_NETWORK_TYPE="Private Access (Private Endpoint)"
          fi
          
          # Generate Redis connection string
          if [[ -n "$REDIS_ACCESS_KEY" && -n "$REDIS_HOST_NAME" && -n "$REDIS_SSL_PORT" ]]; then
            REDIS_CONNECTION_STRING="rediss://:${REDIS_ACCESS_KEY}@${REDIS_HOST_NAME}:${REDIS_SSL_PORT}/0"
          fi
          
          # Download Redis TLS root certificate (Baltimore CyberTrust Root)
          echo "ðŸ“¥ Downloading Redis TLS root certificate..."
          REDIS_TLS_CERT_FILE="external_redis_tls_certificate.pem"
          curl -sL https://cacerts.digicert.com/BaltimoreCyberTrustRoot.crt.pem -o "$REDIS_TLS_CERT_FILE"
          if [[ -f "$REDIS_TLS_CERT_FILE" ]]; then
            echo "âœ… Redis TLS certificate saved to $REDIS_TLS_CERT_FILE"
          else
            echo "âš ï¸  Failed to download Redis TLS certificate"
            REDIS_TLS_CERT_FILE=""
          fi
          
          echo "âœ… Found Redis cache: $REDIS_CACHE_NAME ($REDIS_NETWORK_TYPE)"
        else
          echo "âš ï¸ No Redis cache found"
        fi
        
        echo ""
        echo "ðŸ“‹ ==================================="
        echo "ðŸ“‹ CLUSTER & SERVICES SUMMARY"
        echo "ðŸ“‹ ==================================="
        echo "ðŸŒ Cluster URL: $CLUSTER_URL"
        echo "ðŸ‘¤ Admin Username: $USERNAME"
        echo "ðŸ”‘ Admin Password: $PASSWORD"
        echo "ðŸ“ Kubeconfig: kubeconfig-$(params.aroClusterName).yaml"
        echo ""
        
        if [[ -n "$POSTGRES_SERVER_NAME" ]]; then
          echo "ðŸ—„ï¸ PostgreSQL ($POSTGRES_NETWORK_TYPE):"
          echo "  Server Name: $POSTGRES_SERVER_NAME"
          echo "  FQDN: $POSTGRES_SERVER_FQDN"
          echo "  Admin Username: $POSTGRES_ADMIN_USERNAME"
          echo "  Database: $POSTGRES_DATABASE_NAME"
          if [[ "$POSTGRES_PUBLIC_ACCESS" == "Disabled" ]]; then
            echo "  ðŸ”’ Note: Only accessible from within the VNet/ARO cluster"
          else
            echo "  ðŸ“¡ Note: Accessible from internet (requires firewall rules)"
          fi
          if [[ -n "$POSTGRES_CONNECTION_STRING" ]]; then
            echo "  Connection String: $POSTGRES_CONNECTION_STRING"
          else
            echo "  Connection String: (requires POSTGRES_ADMIN_PASSWORD from secret)"
          fi
          if [[ -n "$POSTGRES_TLS_CERT_FILE" ]]; then
            echo "  ðŸ” TLS Root Certificate: $POSTGRES_TLS_CERT_FILE"
            echo "  ðŸ” TLS Certificate Issuer: DigiCert Global Root G2"
          fi
          echo ""
        else
          echo "ðŸ—„ï¸ PostgreSQL: Not deployed"
          echo ""
        fi
        
        if [[ -n "$REDIS_CACHE_NAME" ]]; then
          echo "ðŸ”´ Redis ($REDIS_NETWORK_TYPE):"
          echo "  Cache Name: $REDIS_CACHE_NAME"
          echo "  Host: $REDIS_HOST_NAME"
          echo "  Port: $REDIS_PORT"
          echo "  SSL Port: $REDIS_SSL_PORT"
          if [[ "$REDIS_PUBLIC_ACCESS" == "Disabled" ]]; then
            echo "  ðŸ”’ Note: Only accessible from within the VNet/ARO cluster"
          else
            echo "  ðŸ“¡ Note: Accessible from internet (requires firewall rules)"
          fi
          if [[ -n "$REDIS_ACCESS_KEY" ]]; then
            echo "  Access Key: $REDIS_ACCESS_KEY"
            echo "  Connection String: $REDIS_CONNECTION_STRING"
          else
            echo "  Access Key: (not available - check permissions)"
            echo "  Connection String: (not available - check permissions)"
          fi
          if [[ -n "$REDIS_TLS_CERT_FILE" ]]; then
            echo "  ðŸ” TLS Certificate: $REDIS_TLS_CERT_FILE"
            echo "  ðŸ” TLS Server Name: $REDIS_HOST_NAME"
            echo "  ðŸ” TLS Certificate Issuer: Baltimore CyberTrust Root"
          fi
          echo ""
        else
          echo "ðŸ”´ Redis: Not deployed"
          echo ""
        fi
        
        # Save comprehensive information to files
        {
          echo "ARO Cluster & Azure Services Information"
          echo "======================================="
          echo "Generated: $(date)"
          echo "Cluster: $ARO_CLUSTER_NAME"
          echo "Resource Group: $ARO_RESOURCE_GROUP"
          echo ""
          echo "CLUSTER ACCESS:"
          echo "  Cluster URL: $CLUSTER_URL"
          echo "  Admin Username: $USERNAME"
          echo "  Admin Password: $PASSWORD"
          echo "  Kubeconfig File: kubeconfig-$(params.aroClusterName).yaml"
          echo ""
          if [[ -n "$POSTGRES_SERVER_NAME" ]]; then
            echo "POSTGRESQL ($POSTGRES_NETWORK_TYPE):"
            echo "  Server Name: $POSTGRES_SERVER_NAME"
            echo "  FQDN: $POSTGRES_SERVER_FQDN"
            echo "  Admin Username: $POSTGRES_ADMIN_USERNAME"
            echo "  Database: $POSTGRES_DATABASE_NAME"
            if [[ "$POSTGRES_PUBLIC_ACCESS" == "Disabled" ]]; then
              echo "  Note: Only accessible from within the VNet/ARO cluster"
            else
              echo "  Note: Accessible from internet (requires firewall rules)"
            fi
            if [[ -n "$POSTGRES_CONNECTION_STRING" ]]; then
              echo "  Connection String: $POSTGRES_CONNECTION_STRING"
            fi
            if [[ -n "$POSTGRES_TLS_CERT_FILE" ]]; then
              echo "  TLS Root Certificate: $POSTGRES_TLS_CERT_FILE"
              echo "  TLS Certificate Issuer: DigiCert Global Root G2"
            fi
            echo ""
          fi
          if [[ -n "$REDIS_CACHE_NAME" ]]; then
            echo "REDIS ($REDIS_NETWORK_TYPE):"
            echo "  Cache Name: $REDIS_CACHE_NAME"
            echo "  Host: $REDIS_HOST_NAME"
            echo "  Port: $REDIS_PORT"
            echo "  SSL Port: $REDIS_SSL_PORT"
            if [[ "$REDIS_PUBLIC_ACCESS" == "Disabled" ]]; then
              echo "  Note: Only accessible from within the VNet/ARO cluster"
            else
              echo "  Note: Accessible from internet (requires firewall rules)"
            fi
            if [[ -n "$REDIS_ACCESS_KEY" ]]; then
              echo "  Access Key: $REDIS_ACCESS_KEY"
              echo "  Connection String: $REDIS_CONNECTION_STRING"
            fi
            if [[ -n "$REDIS_TLS_CERT_FILE" ]]; then
              echo "  TLS Certificate: $REDIS_TLS_CERT_FILE"
              echo "  TLS Server Name: $REDIS_HOST_NAME"
              echo "  TLS Certificate Issuer: Baltimore CyberTrust Root"
            fi
            echo ""
          fi
        } > cluster-and-services-info.txt
        
        echo "âœ… Comprehensive information saved to cluster-and-services-info.txt"
        echo ""
        echo "ðŸ“‹ ============================================"
        echo "ðŸ“‹ TLS CERTIFICATES"
        echo "ðŸ“‹ ============================================"
        echo ""
        
        # Display PostgreSQL TLS certificate in logs
        if [[ -f "$POSTGRES_TLS_CERT_FILE" ]]; then
          echo "ðŸ” PostgreSQL TLS Root Certificate (DigiCert Global Root G2):"
          echo "---BEGIN CERTIFICATE---"
          cat "$POSTGRES_TLS_CERT_FILE"
          echo "---END CERTIFICATE---"
          echo ""
        fi
        
        # Display Redis TLS certificate in logs
        if [[ -f "$REDIS_TLS_CERT_FILE" ]]; then
          echo "ðŸ” Redis TLS Certificate (Baltimore CyberTrust Root):"
          echo "---BEGIN CERTIFICATE---"
          cat "$REDIS_TLS_CERT_FILE"
          echo "---END CERTIFICATE---"
          echo ""
        fi
        
        echo "ðŸ“‹ ============================================"
        echo ""
        echo "ðŸŽ‰ ARO cluster validation, kubeconfig generation, and services discovery completed successfully!"
        echo ""
        echo "ðŸ’¡ All connection details and certificates are displayed in the logs above."
        echo "ðŸ’¡ Copy the information you need directly from the Logs tab!"
        echo ""
        echo "ðŸ“¥ To save certificates locally:"
        echo "   1. Copy the certificate content from logs (between BEGIN/END lines)"
        echo "   2. Save to a .crt or .pem file on your machine"
        
        # Write a brief summary to results (under 4KB for testing)
        echo "ðŸ“¤ Writing result summary..."
        {
          echo "ARO CLUSTER VALIDATION SUMMARY"
          echo "=============================="
          echo "Cluster: $ARO_CLUSTER_NAME"
          echo "Resource Group: $ARO_RESOURCE_GROUP"
          echo "Status: âœ… VALIDATED"
          echo ""
          echo "Cluster URL: $CLUSTER_URL"
          echo "Kubeconfig: kubeconfig-$(params.aroClusterName).yaml"
          echo ""
          if [[ -n "$POSTGRES_SERVER_NAME" ]]; then
            echo "PostgreSQL: âœ… DEPLOYED ($POSTGRES_NETWORK_TYPE)"
            echo "  FQDN: $POSTGRES_SERVER_FQDN"
          else
            echo "PostgreSQL: âŒ NOT DEPLOYED"
          fi
          echo ""
          if [[ -n "$REDIS_CACHE_NAME" ]]; then
            echo "Redis: âœ… DEPLOYED ($REDIS_NETWORK_TYPE)"
            echo "  Host: $REDIS_HOST_NAME"
          else
            echo "Redis: âŒ NOT DEPLOYED"
          fi
          echo ""
          echo "View full details in the Logs tab!"
        } > $(results.cluster-summary.path)
        echo "âœ… Summary written to results (viewable in OpenShift UI)"