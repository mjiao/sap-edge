# SPDX-FileCopyrightText: 2025 SAP edge team
# SPDX-FileContributor: Manjun Jiao (@mjiao)
#
# SPDX-License-Identifier: Apache-2.0

---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: hcp-wait-cluster-ready
spec:
  description: Wait for Hosted Cluster to be available and extract kubeconfig
  params:
    - name: hostedClusterName
      type: string
      description: "Name of the hosted cluster"
    - name: hostedClusterNamespace
      type: string
      description: "Namespace for HostedCluster resources"
      default: "clusters"
    - name: timeoutMinutes
      type: string
      description: "Timeout in minutes to wait for cluster readiness"
      default: "45"
    - name: hubKubeconfigSecretName
      type: string
      description: "Name of the Secret containing kubeconfig for hub cluster (optional, uses in-cluster config if empty)"
      default: ""
  workspaces:
    - name: source
  results:
    - name: kubeconfig-path
      description: "Path to the extracted kubeconfig file"
    - name: api-url
      description: "API URL of the hosted cluster"
    - name: console-url
      description: "Console URL of the hosted cluster"
  steps:
    - name: wait-for-cluster
      image: registry.access.redhat.com/ubi9/ubi
      timeout: "60m"
      workingDir: $(workspaces.source.path)
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        # Parameters
        CLUSTER_NAME="$(params.hostedClusterName)"
        CLUSTER_NS="$(params.hostedClusterNamespace)"
        TIMEOUT_MINUTES="$(params.timeoutMinutes)"
        TIMEOUT_SECONDS=$((TIMEOUT_MINUTES * 60))
        HUB_KUBECONFIG_SECRET="$(params.hubKubeconfigSecretName)"

        echo "=========================================="
        echo "HCP Wait Cluster Ready Task"
        echo "=========================================="
        echo "Cluster Name: ${CLUSTER_NAME}"
        echo "Namespace: ${CLUSTER_NS}"
        echo "Timeout: ${TIMEOUT_MINUTES} minutes"
        echo "=========================================="

        # Install required tools
        echo "üì¶ Installing required packages..."
        dnf install -y jq > /dev/null 2>&1

        echo "üì¶ Installing OpenShift CLI..."
        curl -sL https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/openshift-client-linux.tar.gz | tar xz
        mv oc kubectl /usr/local/bin/
        oc version --client

        # Configure hub cluster kubeconfig if provided
        if [[ -n "${HUB_KUBECONFIG_SECRET}" ]]; then
          echo "üîê Extracting hub cluster kubeconfig from secret: ${HUB_KUBECONFIG_SECRET}..."
          HUB_KUBECONFIG="/tmp/hub-kubeconfig"
          # Try different common key names for kubeconfig in secrets
          if kubectl get secret "${HUB_KUBECONFIG_SECRET}" -o jsonpath='{.data.kubeconfig}' 2>/dev/null | base64 -d > "${HUB_KUBECONFIG}" 2>/dev/null && [[ -s "${HUB_KUBECONFIG}" ]]; then
            echo "‚úÖ Kubeconfig extracted (key: kubeconfig)"
          elif kubectl get secret "${HUB_KUBECONFIG_SECRET}" -o jsonpath='{.data.config}' 2>/dev/null | base64 -d > "${HUB_KUBECONFIG}" 2>/dev/null && [[ -s "${HUB_KUBECONFIG}" ]]; then
            echo "‚úÖ Kubeconfig extracted (key: config)"
          elif kubectl get secret "${HUB_KUBECONFIG_SECRET}" -o jsonpath='{.data.value}' 2>/dev/null | base64 -d > "${HUB_KUBECONFIG}" 2>/dev/null && [[ -s "${HUB_KUBECONFIG}" ]]; then
            echo "‚úÖ Kubeconfig extracted (key: value)"
          else
            echo "‚ùå Failed to extract kubeconfig from secret '${HUB_KUBECONFIG_SECRET}'"
            echo "   Secret should have kubeconfig data under key 'kubeconfig', 'config', or 'value'"
            exit 1
          fi
          chmod 600 "${HUB_KUBECONFIG}"
          export KUBECONFIG="${HUB_KUBECONFIG}"
          echo "‚úÖ Using hub kubeconfig for cluster operations"
          oc whoami
        else
          echo "‚ÑπÔ∏è  No hub kubeconfig secret provided, using in-cluster service account"
        fi

        # Verify HostedCluster exists
        echo "üîç Verifying HostedCluster exists..."
        if ! oc get hostedcluster "${CLUSTER_NAME}" -n "${CLUSTER_NS}" > /dev/null 2>&1; then
          echo "‚ùå HostedCluster '${CLUSTER_NAME}' not found in namespace '${CLUSTER_NS}'"
          exit 1
        fi
        echo "‚úÖ HostedCluster found"

        # Wait for HostedCluster to be available
        echo "‚è≥ Waiting for HostedCluster to be available..."
        START_TIME=$(date +%s)

        while true; do
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))

          if [[ ${ELAPSED} -ge ${TIMEOUT_SECONDS} ]]; then
            echo "‚ùå Timeout reached after ${TIMEOUT_MINUTES} minutes"
            echo ""
            echo "üìã Current HostedCluster status:"
            oc get hostedcluster "${CLUSTER_NAME}" -n "${CLUSTER_NS}" -o yaml
            echo ""
            echo "üìã HostedCluster conditions:"
            oc get hostedcluster "${CLUSTER_NAME}" -n "${CLUSTER_NS}" -o jsonpath='{.status.conditions}' | jq .
            exit 1
          fi

          # Get cluster availability status
          AVAILABLE=$(oc get hostedcluster "${CLUSTER_NAME}" -n "${CLUSTER_NS}" \
            -o jsonpath='{.status.conditions[?(@.type=="Available")].status}' 2>/dev/null || echo "Unknown")

          # Get progress message
          PROGRESS=$(oc get hostedcluster "${CLUSTER_NAME}" -n "${CLUSTER_NS}" \
            -o jsonpath='{.status.conditions[?(@.type=="Progressing")].message}' 2>/dev/null || echo "Unknown")

          # Get degraded status
          DEGRADED=$(oc get hostedcluster "${CLUSTER_NAME}" -n "${CLUSTER_NS}" \
            -o jsonpath='{.status.conditions[?(@.type=="Degraded")].status}' 2>/dev/null || echo "Unknown")

          # Calculate elapsed time in human readable format
          ELAPSED_MIN=$((ELAPSED / 60))
          ELAPSED_SEC=$((ELAPSED % 60))

          echo "‚è≥ [${ELAPSED_MIN}m${ELAPSED_SEC}s] Available=${AVAILABLE} | Degraded=${DEGRADED}"
          echo "   Progress: ${PROGRESS:0:100}..."

          if [[ "${AVAILABLE}" == "True" ]]; then
            echo ""
            echo "‚úÖ HostedCluster is available!"
            break
          fi

          if [[ "${DEGRADED}" == "True" ]]; then
            echo "‚ö†Ô∏è  Cluster is degraded, but continuing to wait..."
          fi

          sleep 30
        done

        # Wait for NodePool workers to be ready
        echo ""
        echo "‚è≥ Waiting for NodePool workers to be ready..."
        NODEPOOL_NAME="${CLUSTER_NAME}-workers"

        while true; do
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))

          if [[ ${ELAPSED} -ge ${TIMEOUT_SECONDS} ]]; then
            echo "‚ùå Timeout reached waiting for NodePool workers"
            oc get nodepool "${NODEPOOL_NAME}" -n "${CLUSTER_NS}" -o yaml
            exit 1
          fi

          READY_REPLICAS=$(oc get nodepool "${NODEPOOL_NAME}" -n "${CLUSTER_NS}" \
            -o jsonpath='{.status.replicas}' 2>/dev/null || echo "0")
          EXPECTED_REPLICAS=$(oc get nodepool "${NODEPOOL_NAME}" -n "${CLUSTER_NS}" \
            -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")

          ELAPSED_MIN=$((ELAPSED / 60))
          ELAPSED_SEC=$((ELAPSED % 60))

          echo "‚è≥ [${ELAPSED_MIN}m${ELAPSED_SEC}s] NodePool: ${READY_REPLICAS}/${EXPECTED_REPLICAS} workers ready"

          if [[ "${READY_REPLICAS}" == "${EXPECTED_REPLICAS}" ]] && [[ "${READY_REPLICAS}" != "0" ]]; then
            echo ""
            echo "‚úÖ All NodePool workers are ready!"
            break
          fi

          sleep 30
        done

        # Extract kubeconfig
        echo ""
        echo "üîê Extracting kubeconfig from secret..."
        KUBECONFIG_SECRET="${CLUSTER_NAME}-admin-kubeconfig"
        KUBECONFIG_PATH="$(workspaces.source.path)/hosted-kubeconfig"

        if ! oc get secret "${KUBECONFIG_SECRET}" -n "${CLUSTER_NS}" > /dev/null 2>&1; then
          echo "‚ùå Kubeconfig secret '${KUBECONFIG_SECRET}' not found"
          exit 1
        fi

        oc get secret "${KUBECONFIG_SECRET}" -n "${CLUSTER_NS}" \
          -o jsonpath='{.data.kubeconfig}' | base64 -d > "${KUBECONFIG_PATH}"

        chmod 600 "${KUBECONFIG_PATH}"
        echo "‚úÖ Kubeconfig saved to: ${KUBECONFIG_PATH}"

        # Get API URL
        API_HOST=$(oc get hostedcluster "${CLUSTER_NAME}" -n "${CLUSTER_NS}" \
          -o jsonpath='{.status.controlPlaneEndpoint.host}' 2>/dev/null || echo "")
        API_PORT=$(oc get hostedcluster "${CLUSTER_NAME}" -n "${CLUSTER_NS}" \
          -o jsonpath='{.status.controlPlaneEndpoint.port}' 2>/dev/null || echo "6443")

        if [[ -n "${API_HOST}" ]]; then
          API_URL="https://${API_HOST}:${API_PORT}"
        else
          API_URL="unknown"
        fi

        # Get console URL (if available)
        CONSOLE_URL=$(oc get hostedcluster "${CLUSTER_NAME}" -n "${CLUSTER_NS}" \
          -o jsonpath='{.status.oauthCallbackURLTemplate}' 2>/dev/null || echo "")
        CONSOLE_URL=${CONSOLE_URL%/oauth2callback/*}
        if [[ -z "${CONSOLE_URL}" ]]; then
          CONSOLE_URL="pending"
        fi

        # Write results
        echo "${KUBECONFIG_PATH}" > $(results.kubeconfig-path.path)
        echo "${API_URL}" > $(results.api-url.path)
        echo "${CONSOLE_URL}" > $(results.console-url.path)

        # Verify access to hosted cluster
        echo ""
        echo "üîç Verifying access to hosted cluster..."
        export KUBECONFIG="${KUBECONFIG_PATH}"

        echo ""
        echo "üìã Hosted cluster nodes:"
        oc get nodes -o wide

        echo ""
        echo "üìã Hosted cluster namespaces:"
        oc get namespaces | head -20

        echo ""
        echo "=========================================="
        echo "‚úÖ Hosted cluster is ready and accessible!"
        echo "=========================================="
        echo "API URL: ${API_URL}"
        echo "Console URL: ${CONSOLE_URL}"
        echo "Kubeconfig: ${KUBECONFIG_PATH}"
        echo "=========================================="
