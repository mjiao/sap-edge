# SPDX-FileCopyrightText: 2025 SAP edge team
# SPDX-FileContributor: Manjun Jiao (@mjiao)
#
# SPDX-License-Identifier: Apache-2.0

---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: aro-deploy-with-eic-services
spec:
  description: Deploy ARO cluster with EIC services (PostgreSQL, Redis, and Quay storage)
  params:
    - name: aroLocation
      type: string
      description: "ARO location"
      default: "northeurope"
    - name: aroClusterName
      type: string
      description: "ARO cluster name"
    - name: aroVersion
      type: string
      description: "ARO version"
      default: "4.15.35"
    - name: azureSecretName
      type: string
      description: "Name of the Kubernetes Secret containing Azure service principal credentials, ARO resource group, and ARO domain"
      default: "azure-sp-secret"
    - name: pullSecretName
      type: string
      description: "Name of the Kubernetes Secret containing Red Hat pull secret"
      default: "redhat-pull-secret"
    - name: postgresAdminPasswordSecretName
      type: string
      description: "Name of the Kubernetes Secret containing PostgreSQL admin password"
      default: "azure-postgres-admin-password"
    - name: deployPostgres
      type: string
      description: "Whether to deploy PostgreSQL (true/false)"
      default: "true"
    - name: deployRedis
      type: string
      description: "Whether to deploy Redis (true/false)"
      default: "true"
    - name: deployQuay
      type: string
      description: "Whether to deploy Quay storage (true/false)"
      default: "true"
  workspaces:
    - name: source
  steps:
    - name: deploy-aro-with-eic-services
      image: registry.access.redhat.com/ubi9/ubi
      timeout: "336h"      # Extended timeout for validation periods
      workingDir: $(workspaces.source.path)
      env:
        - name: ARO_LOCATION
          value: "$(params.aroLocation)"
        - name: ARO_CLUSTER_NAME
          value: "$(params.aroClusterName)"
        - name: ARO_VERSION
          value: "$(params.aroVersion)"
        - name: DEPLOY_POSTGRES
          value: "$(params.deployPostgres)"
        - name: DEPLOY_REDIS
          value: "$(params.deployRedis)"
        - name: DEPLOY_QUAY
          value: "$(params.deployQuay)"
      envFrom:
        - secretRef:
            name: $(params.azureSecretName)
        - secretRef:
            name: $(params.pullSecretName)
        - secretRef:
            name: $(params.postgresAdminPasswordSecretName)
      script: |
        #!/usr/bin/env bash
        set -euo pipefail
        
        # Environment variables are now directly available from secrets (no conversion needed)
        # PostgreSQL admin password must be available as POSTGRES_ADMIN_PASSWORD from the secret
        echo "üîê PostgreSQL admin password available from secret mount..."
        
        # Validate POSTGRES_ADMIN_PASSWORD is set and export it
        if [[ -z "${POSTGRES_ADMIN_PASSWORD:-}" ]]; then
          echo "‚ùå ERROR: POSTGRES_ADMIN_PASSWORD environment variable is not set!"
          echo "   The secret '$(params.postgresAdminPasswordSecretName)' must contain a key named 'POSTGRES_ADMIN_PASSWORD'"
          exit 1
        fi
        export POSTGRES_ADMIN_PASSWORD
        echo "‚úÖ PostgreSQL admin password is set (length: ${#POSTGRES_ADMIN_PASSWORD} characters)"
        
        echo "üì¶ Installing required packages..."
        # Install make, libicu, and jq first (needed for makefile operations)
        dnf install -y make libicu jq
        
        echo "üì¶ Installing Azure CLI..."
        # Install Azure CLI using the official Microsoft repository
        rpm --import https://packages.microsoft.com/keys/microsoft.asc
        dnf install -y https://packages.microsoft.com/config/rhel/9.0/packages-microsoft-prod.rpm
        dnf clean all
        # Pin to a stable version to avoid HTTP client issues
        dnf install -y azure-cli-2.59.0
        
        echo "üîê Logging into Azure..."
        make azure-login

        # Export required environment variables for all makefile operations
        export ARO_CLUSTER_NAME="$ARO_CLUSTER_NAME"
        export ARO_RESOURCE_GROUP="$ARO_RESOURCE_GROUP"
        export ARO_LOCATION="$ARO_LOCATION"
        export ARO_VERSION="$ARO_VERSION"
        export DEPLOY_POSTGRES="$DEPLOY_POSTGRES"
        export DEPLOY_REDIS="$DEPLOY_REDIS"
        export DEPLOY_QUAY="$DEPLOY_QUAY"

        echo "üîç Checking Azure services status..."
        # Set fixed PostgreSQL server name
        POSTGRES_SERVER_NAME="postgres-${ARO_CLUSTER_NAME}"
        
        # Initialize deployment flag
        CLUSTER_EXISTS=false
        
        # Check if cluster already exists
        echo "üîç Checking existing cluster status..."
        echo "Using cluster name: $ARO_CLUSTER_NAME"
        echo "Using resource group: $ARO_RESOURCE_GROUP"

        CLUSTER_EXISTS_RESULT=$(make aro-cluster-exists | tail -1)
        if [[ "$CLUSTER_EXISTS_RESULT" == "true" ]]; then
          echo "‚úÖ Cluster EXISTS"
          CLUSTER_EXISTS=true
          CLUSTER_STATUS=$(make aro-cluster-status | tail -1)
          echo "Found existing cluster with status: $CLUSTER_STATUS"
          
          if [[ "$CLUSTER_STATUS" == "Failed" ]]; then
            echo "üóëÔ∏è Cluster is in failed state, cleaning up..."
            make aro-cleanup-failed
            echo "‚è≥ Waiting for failed cluster deletion..."
            sleep 30
            CLUSTER_EXISTS=false  # After deletion, cluster doesn't exist
          elif [[ "$CLUSTER_STATUS" == "Succeeded" ]]; then
            echo "‚úÖ Cluster already exists and is ready!"
            echo "‚ÑπÔ∏è  Assuming all Azure services (PostgreSQL, Redis, Quay storage) were deployed with the cluster"
            echo "‚úÖ Skipping deployment - cluster and services already exist!"
              exit 0
          elif [[ "$CLUSTER_STATUS" == "Creating" || "$CLUSTER_STATUS" == "Updating" ]]; then
            echo "‚è≥ Cluster is in state: $CLUSTER_STATUS, waiting for completion..."
            if make aro-wait-for-ready; then
              echo "‚úÖ Cluster is ready!"
              # Services will be checked in the main deployment section
            else
              echo "‚ùå Cluster deployment failed, cleaning up..."
              make aro-cleanup-failed
              sleep 30
              CLUSTER_EXISTS=false  # After deletion, cluster doesn't exist
            fi
          fi
        else
          echo "üìã No existing cluster found - will deploy full ARO cluster with EIC services"
        fi
        
        echo "üèóÔ∏è Creating resource group (idempotent)..."
        make aro-resource-group-create
        
        # Deployment decision logic based on cluster existence
        echo "üîç Deployment decision: CLUSTER_EXISTS=$CLUSTER_EXISTS"
        
        if [[ "$CLUSTER_EXISTS" == "false" ]]; then
          echo "üöÄ Deploying full ARO cluster with EIC services (PostgreSQL and Redis)..."
          
          # Final safety check - double-check cluster doesn't exist before deploying
          echo "üîç Final safety check before deployment..."
          make aro-final-safety-check
          
          make aro-deploy-test

          # Wait for ARO cluster to be fully ready before creating DNS records
          echo "‚è≥ Waiting for ARO cluster to be ready..."
          make aro-wait-for-ready

          echo "üîÑ Creating domain records for ARO..."
          make domain-records
        else
          echo "‚úÖ Cluster exists - nothing to deploy!"
        fi

        echo "‚úÖ ARO deployment with EIC services completed successfully!" 